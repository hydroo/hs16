\section{Support in Score-P and Vampir}

In the following sections the level of support for modern C++ by Score-P and Vampir will be discussed. This is achieved by implementing several small example programs that make use of these features. The source code of these examples can be found in Appendix \ref{app:scorep}. The code is compiled with gcc 6.2.1, using the compiler plugin from Score-P 3.0. The results are examined using Vampir 9.0.

\subsection{Concurrency}\label{scorep:conc}

In this section the various concurrency constructs introduced in C++11 will be discussed.

\subsubsection{\texttt{std::async}}\label{scorep:conc_async}

As mentioned in Section \ref{queue} \texttt{std::async} is a high-level construct to asynchronously run tasks. The underlying management of this asynchronous is not exposed to the library user; instead, it is guaranteed that the result is returned upon a call to \texttt{future::get} (\texttt{std::async} returns a \texttt{std::future}). This may lead to blocking on the caller's side if the asynchronous task has not been completed yet. This potential bottleneck makes any application using \texttt{std::async} a natural target for profiling, even more so as its default behaviour with regard to thread spawning is implementation specific.

There are three test cases in this document: One for the default behaviour (Appendix \ref{app:scorep_conc_async_default}), another for explicit asynchronous evaluation (Appendix \ref{app:scorep_conc_async_async}) and a third for explicit lazy evaluation (Appendix \ref{app:scorep_conc_async_lazy}).

The first two test cases fail with the following error message:

\begin{verbatim}
$ SCOREP_ENABLE_TRACING=1 ./future_default                                      
[Score-P] src/measurement/thread/create_wait/scorep_thread_create_wait
          _pthread.c:84: Fatal: Bug 'tpd == 0': Invalid Pthread thread
          specific data object. Please ensure that all pthread_create
          calls are instrumented.
[Score-P] Please report this to support@score-p.org. Thank you.
[Score-P] Try also to preserve any generated core dumps.
[Score-P] src/measurement/thread/create_wait/scorep_thread_create_wait
          _pthread.c:84: Fatal: Bug 'tpd == 0': Invalid Pthread thread
          specific data object. Please ensure that all pthread_create
          calls are instrumented.[1]    8405 abort (core dumped)
\end{verbatim}

Unfortunately, imitating \texttt{std::async}'s behaviour with Pthreads for the sake of this document is impossible as the thread management behind the call is implementation-defined: the library may spawn simple Pthreads internally, rely on a thread pool or do something entirely different.

The lazy evaluation test case executes successfully; however, because the code in question is not executed in a separate thread the inspection of Score-P's trace file shows nothing noteworthy (see Figures \ref{scorep:conc_async_lazy_timeline} and \ref{scorep:conc_async_lazy_summary}).

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_async_lazy_timeline.png}
		\caption{Master timeline for \texttt{std::async} with lazy evaluation}
		\label{scorep:conc_async_lazy_timeline}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_async_lazy_summary.png}
		\caption{Function summary for \texttt{std::async} with lazy evaluation}
		\label{scorep:conc_async_lazy_summary}
	\end{center}
\end{figure}

\subsubsection{\texttt{std::thread}}\label{scorep:conc_thread}

When compared to \texttt{std::async} \texttt{std::thread} follows a much more ``low level'' approach as thread execution is now entirely in the hands of the user. Naturally C++11 threads are profiling targets as well as they build the very foundation of modern C++ style concurrent programming.

There is are two test cases for \texttt{std::thread}: the first spawns a thread and joins it afterwards (Appendix \ref{app:conc_thread_join}), the second spawns a thread and detaches it, making it unjoinable (Appendix \ref{app:conc_thread_detach}).

Both test cases fail to execute and produce the same error message already known from Section \ref{scorep:conc_async}. Because \texttt{std::thread} simply wraps a Pthread (at least in libstdc++) its behaviour can be emulated (see Figures \ref{scorep:conc_pthread_join_timeline} and \ref{scorep:conc_pthread_join_summary} and Figures \ref{scorep:conc_pthread_detach_timeline} and \ref{scorep:conc_pthread_detach_summary}, respectively).

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_pthread_join_timeline.png}
		\caption{Emulated master timeline for a joined \texttt{std::thread}}
		\label{scorep:conc_pthread_join_timeline}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_pthread_join_summary.png}
		\caption{Emulated function summary for a joined \texttt{std::thread}}
		\label{scorep:conc_pthread_join_summary}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_pthread_detach_timeline.png}
		\caption{Emulated master timeline for a detached \texttt{std::thread}}
		\label{scorep:conc_pthread_detach_timeline}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_pthread_detach_summary.png}
		\caption{Emulated function summary for a detached \texttt{std::thread}}
		\label{scorep:conc_pthread_detach_summary}
	\end{center}
\end{figure}

\subsubsection{Summary}

At the time of writing, Score-P's support for C++11 multithreading is nonexistent as the error messages from Section \ref{scorep:conc_async} and Section \ref{scorep:conc_thread} show. The likely cause for these errors lies in the internals of the GNU C++ compiler's standard library as the threading support library is compiled into the shared library object. Score-P is unable to instrument this already compiled code and crashes upon execution once it encounters an unknown thread.

The solution for this problem would be a more graceful handling of ``unknown threads'': Instead of crashing Score-P should simply register them on the fly.

\subsection{Synchronization}

With the introduction of the thread support library synchronization primitives were added to the standard library as well. As such primitives are able to block thread execution profiling their behaviour is especially interesting in a HPC context. In this section the mutual exclusion constructs (\texttt{std::mutex}) and condition variables (\texttt{std::condition\_variable}) are evaluated. Due to the problems shown in Section \ref{scorep:conc} the spawned threads in the testcases are classic Pthreads.

\subsubsection{\texttt{std::mutex}}\label{scorep:sync_mutex}

\texttt{std::mutex} and its more specialized siblings \texttt{std::timed\_mutex}, \texttt{std::recursive\_mutex} and \texttt{std::recursive\_timed\_mutex} provide simple mechanisms for mutual exclusion between threads. Like similar primitives these constructs provide mechanisms for locking and unlocking. However, directly accessing these mechanisms is not exception-safe which is why they are usually managed by \texttt{std::unique\_lock} or \texttt{std::lock\_guard}. Relying on \gls{raii} these primitives will automatically unlock the managed \texttt{std::mutex} once they go out of scope.

The test case (see Appendix \ref{app:scorep_sync_mutex}) utilizes them as well for synchronization between two threads instead of locking the \texttt{std::mutex} manually. Upon execution the test case itself works as expected: Pthreads are spawned and \texttt{std::mutex} blocks one of them while being locked by the other.

Score-P on the other hand is not able to fully parse the instruction flow correctly: instead of instrumenting the calls to the standard library facilites it detects and instruments the underlying  Pthread mechanisms utilized by the library implementation (see Figures \ref{scorep:sync_pthread_mutex_timeline} and \ref{scorep:sync_pthread_mutex_summary}). This can be explained by the compiler's aggressive inlining of the \gls{stl} functions which prevents Score-P from instrumenting the actual function call.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_pthread_mutex_timeline.png}
		\caption{Master timeline for thread synchronization with \texttt{std::mutex}}
		\label{scorep:sync_pthread_mutex_timeline}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_pthread_mutex_summary.png}
		\caption{Function summary for thread synchronization with \texttt{std::mutex}}
		\label{scorep:sync_pthread_mutex_summary}
	\end{center}
\end{figure}

\subsubsection{\texttt{std::condition\_variable}}

The other synchronization primitive added to the standard library with C++11 is \texttt{std::condition\_variable} which allows threads to communicate with each other. A \texttt{std::condition\_variable} is always associated with a \texttt{std::mutex} but offers more fine-grained control via its notification mechanisms -- a thread can either wake up one other waiting thread or all of them.

The test case (see Appendix \ref{app:scorep_sync_cv}) spawns four Pthreads, of which three are waiting for the fourth to signal them. Once they receive the notification they execute their instructions in parallel.

Like the simpler \texttt{std::mutex} test case (see Section \ref{scorep:sync_mutex}) this program executes successfully and suffers from the same problems with inlining (see Figures \ref{scorep:sync_pthread_cv_timeline} and \ref{scorep:sync_pthread_cv_summary}).

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_pthread_cv_timeline.png}
		\caption{Master timeline for thread synchronization with \texttt{std::condition\_variable}}
		\label{scorep:sync_pthread_cv_timeline}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_pthread_cv_summary.png}
		\caption{Function summary for thread synchronization with \texttt{std::condition\_variable}}
		\label{scorep:sync_pthread_cv_summary}
	\end{center}
\end{figure}

\subsubsection{Summary}

While Score-P's support for synchronization primitives is better than its support for C++11 threads it is not perfect. Due to aggressive compiler inlining the \gls{stl} functions are optimized away before Score-P can instrument them. In order to change this Score-P would need a mechanism to instrument the \gls{stl}'s interface without automatically instrumenting all the implementation details behind the interface because those are likely to be inlined as well.

\subsection{File I/O}

While file I/O is not a new concept and has not changed with C++11 its performance penalties are still an important issue to consider in an HPC context. In this section file I/O using binary file streams, text file streams and (for comparison) the C API will be evaluated.

\subsubsection{Binary I/O}\label{scorep:binary_fstream}

The first test case (see Appendix \ref{app:scorep_binary_fstream}) generates a \texttt{std::vector} with random integer values and writes them to a file. The file itself is created and modified by a \texttt{std::ofstream} opened in binary mode. It is then closed and opened again in binary mode by a \texttt{std::ifstream} which then proceeds to read its contents into another \texttt{std::vector}.

As the Figures \ref{scorep:binary_fstream_timeline} and \ref{scorep:binary_fstream_summary} show all of the aforementioned  are ignored entirely by Score-P's instrumentation.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_binary_fstream_timeline.png}
		\caption{Master timeline for file operations using \texttt{std::fstream} in binary mode}
		\label{scorep:binary_fstream_timeline}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_binary_fstream_summary.png}
		\caption{Function summary for file operations using \texttt{std::fstream} in binary mode}
		\label{scorep:binary_fstream_summary}
	\end{center}
\end{figure}

\subsubsection{Text I/O}

The second test case (see Appendix \ref{app:scorep_text_fstream}) uses a \texttt{std::ofstream} in text mode to output a text to a file. This file is then closed and reopened by a \texttt{std::ifstream} in text mode, the contents are printed to \texttt{stdout}.

Again, Score-P fails to instrument any of the instructions (Figures \ref{scorep:text_fstream_timeline} and \ref{scorep:text_fstream_summary}).

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_text_fstream_timeline.png}
		\caption{Master timeline for file operations using \texttt{std::fstream} in text mode}
		\label{scorep:text_fstream_timeline}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_text_fstream_summary.png}
		\caption{Function summary for file operations using \texttt{std::fstream} in text mode}
		\label{scorep:text_fstream_summary}
	\end{center}
\end{figure}

\subsubsection{C-style I/O}

The results of the previous sections may lead to the conclusion that the file operations are inlined by the compiler and thus not visible to Score-P. The third test case implements the functionality from Section \ref{scorep:binary_fstream} using the API inherited from the C standard library (see Appendix \ref{app:scorep_c_io}).

Figures \ref{scorep:c_io_timeline} and \ref{scorep:c_io_summary} show that the issue is not related to inlining. 

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_c_io_timeline.png}
		\caption{Master timeline for file operations using the C standard library API}
		\label{scorep:c_io_timeline}
	\end{center}
\end{figure}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{img/scorep_text_fstream_summary.png}
		\caption{Function summary for file operations using the C standard library API}
		\label{scorep:c_io_summary}
	\end{center}
\end{figure}

\subsubsection{Summary}

At the time of writing Score-P does not support the instrumentation of file I/O. In order to change this it would need a way to instrument system calls as those are called internally by standard library file operations.

\subsection{Lambdas}

Lambda functions are especially useful when used in conjunction with the functions found in the header file \texttt{<algorithm>}. This naturally makes them a target of interest in a profiling context. Usually they are inlined because of their small code size which renders them invisible for Score-P.

In cases where inlining does not occur Score-P faces two minor naming issues. The first issue can be reproduced by the following code:

\begin{lstlisting}
auto my_lambda = [](int i) { //... };
\end{lstlisting}

If this code does not get inlined for whatever reason\footnote{Unfortunately, this behaviour was not reliably reproducible which is why there is no test case in the appendix. The lambda's symbols are present in the executable but they are still not visible to Score-P.} Score-P will show the following name:

\begin{lstlisting}
main::{lambda(int)#2}::operator()(int) const
\end{lstlisting}

This naming is very unintuitive and does not help the user in quickly identifying hotspots. The situation becomes worse when using an \texttt{auto} parameter, a feature introduced in C++14:

\begin{lstlisting}
auto my_lambda = [](auto i) { // ... };

_ZZ4mainENKUlTE_clIiEEDaS_ // called with "int" parameter
_ZZ4mainENKUlTE_clIdEEDaS_ // called with "double" parameter
\end{lstlisting}

Both issues are not Score-P's fault but originate in GCC's naming and mangling scheme. To work around this, Score-P would need to implement a custom naming mechanism which works around the one imposed by GCC.