\begin{appendix}

\section{Basic Blowfish Implementation}\label{app:blowfish}

\subsection{blowfish.h}

\begin{lstlisting}[language=C++]
namespace bf
{
    constexpr auto rounds = 16;
    
    struct key {
        array<uint32_t, rounds + 2> p;
        array<uint32_t, 4 * 256> s;
    };
    
    enum class enc {
        encrypt,
        decrypt
    };
    
    auto set_key(const vector<uint8_t>& data) -> key;
    auto encrypt(array<uint32_t, 2>& data, const key& k) -> void;
    auto decrypt(array<uint32_t, 2>& data, const key& k) -> void;
    
    auto ecb_encrypt(const vector<uint8_t>& in, vector<uint8_t>& out, const key& k, enc e) -> void;
}
\end{lstlisting}

\subsection{ecb.cpp}

\begin{lstlisting}[language=C++]
namespace bf
{
    namespace
    {
        template <class OutputIt>
        inline auto n2l(OutputIt& c, std::uint32_t& l) -> void
        {
            l = static_cast<uint32_t>(*(c++)) << 24L;
            l |= static_cast<uint32_t>(*(c++)) << 16L;
            l |= static_cast<uint32_t>(*(c++)) << 8L;
            l |= static_cast<uint32_t>(*(c++));
        }
        
        template <class InputIt>
        inline auto l2n(std::uint32_t l, InputIt& c) -> void
        {
            *(c++) = static_cast<uint32_t>((l >> 24L) & 0xFF);
            *(c++) = static_cast<uint32_t>((l >> 16L) & 0xFF);
            *(c++) = static_cast<uint32_t>((l >> 8L) & 0xFF);
            *(c++) = static_cast<uint32_t>(l & 0xFF);
        }
    }
    
    auto ecb_encrypt(const vector<uint8_t>& in, vector<uint8_t>& out, const key& k, enc e) -> void
    {
        auto l = uint32_t{};
        auto d = array<uint32_t, 2>{};
        auto in_it = begin(in);

        n2l(in_it, l);
        d.at(0) = l;
        
        n2l(in_it, l);
        d.at(1) = l;
        
        if(e == enc::encrypt)
            encrypt(d, k);
        else
            decrypt(d, k);
            
        auto out_it = begin(out);
        
        l = d.at(0);
        l2n(l, out_it);
        
        l = d.at(1);
        l2n(l, out_it);
        
        l = 0;
        d.at(0) = 0;
        d.at(1) = 0;
    }
\end{lstlisting}

\subsection{encrypt.cpp}

\begin{lstlisting}[language=C++]
namespace bf
{
    namespace
    {
        template <class InputIt, class S>
        inline auto encr(InputIt pbegin, InputIt pend, const S& s, uint32_t& l, uint32_t& r) -> void
        {
            for_each(pbegin, pend, [&l, &r, &s](const auto p)
                {
                    l ^= p;
                    l ^= (((s.at(          ((r >> 24) & 0xFF))  +
                            s.at(0x0100U + ((r >> 16) & 0xFF))) ^
                            s.at(0x0200U + ((r >> 8 ) & 0xFF))) +
                            s.at(0x0300U + ((r      ) & 0xFF)) & 0xFFFFFFFFU);
                    swap(l, r);
                }
            );
        }
    }
    
    auto encrypt(array<uint32_t, 2>& data, const key& k) -> void
    {
        const auto& p = k.p;
        const auto& s = k.s;
        auto l = data.at(0) ^ p.at(0);
        auto r = data.at(1);
        
        encr(begin(p) + 1, end(p), s, r, l);
        
        r ^= p.at(rounds + 1);
        
        data.at(0) = r & 0xFFFFFFFFU;
        data.at(1) = l & 0xFFFFFFFFU;
    }
    
    auto decrypt(array<uint32_t, 2>& data, const key& k) -> void
    {
        const auto& p = k.p;
        const auto& s = k.s;
        auto l = data.at(0) ^ p.at(rounds + 1);
        auto r = data.at(1);
        
        encr(rbegin(p), rend(p) - 1, s, r, l);
        
        r ^= p.at(0);
        
        data.at(0) = r & 0xFFFFFFFFU;
        data.at(1) = r & 0xFFFFFFFFU;
    }
}
\end{lstlisting}

\subsection{set\_key.cpp}

\begin{lstlisting}[language=C++]
namespace bf
{
    auto set_key(const vector<uint8_t>& data) -> key
    {
        // init is a constexpr variable of type key
        // which contains the numbers of Pi in
        // hexadecimal notation (see bf_pi.h in
        // OpenSSL's implementation)
        auto k = init;
        
        auto len = data.size();
        if(len > (rounds + 2) * 4
            len = (rounds + 2) * 4;
            
        auto d = begin(data);
        auto e = d + len;
        
        for(auto i = 0; i < rounds + 2; ++i)
        {
            auto ri = *(d++);
            if(d >= e)
                d = begin(data);
                
            for(auto j = 0; j < 3; ++j)
            {
                ri <<= 8;
                ri |= *(d++);
                if(d >= e)
                    d = begin(data);
            }
            
            k.p.at(i) ^= ri;
        }
        
        auto in = array<uint32_t, 2>{0, 0};
        for(auto i = 0; i < rounds + 2; i += 2)
        {
            encrypt(in, k);
            k.p.at(i) = in.at(0);
            k.p.at(i + 1) = in.at(1);
        }
        
        for(auto i = 0; i < 4 * 256; i += 2)
        {
            encrypt(in, k);
            k.s.at(i) = in.at(0);
            k.s.at(i + 1) = in.at(1);
        }
        
        return k;
}
\end{lstlisting}

\section{Score-P / Vampir Examples}\label{app:scorep}

\subsection{Concurrency}\label{app:scorep_conc}

\subsubsection{\texttt{std::async} -- default behaviour}\label{app:scorep_conc_async_default}

\begin{lstlisting}
#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <future>
#include <iterator>
#include <numeric>
#include <vector>

constexpr auto vec_size = std::size_t{1000000};

auto task1() -> void
{
    // fill a vector with values (vec_size, 0] and sort it
    auto vec = std::vector<std::int32_t>{vec_size};
    std::iota(std::rbegin(vec), std::rend(vec), 0);
    std::sort(std::begin(vec), std::end(vec));
}

auto task2() -> std::int32_t
{
    // fill a vector with random values and return the maximum
    auto vec = std::vector<std::int32_t>{vec_size};
    std::generate(std::begin(vec), std::end(vec), std::rand);
    auto it = std::max_element(std::begin(vec), std::end(vec));
    return *it;
}

auto main() -> int
{
    auto f1 = std::async(task1);
    auto f2 = std::async(task2);
    
    f1.get(); // task1 has return type void
    auto res = f2.get();
    
    return 0;
}
\end{lstlisting}

\subsubsection{\texttt{std::async} -- asynchronous evaluation}\label{app:scorep_conc_async_async}

\begin{lstlisting}
#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <future>
#include <iterator>
#include <numeric>
#include <vector>

constexpr auto vec_size = std::size_t{1000000};

auto task1() -> void
{
    // fill a vector with values (vec_size, 0] and sort it
    auto vec = std::vector<std::int32_t>{vec_size};
    std::iota(std::rbegin(vec), std::rend(vec), 0);
    std::sort(std::begin(vec), std::end(vec));
}

auto task2() -> std::int32_t
{
    // fill a vector with random values and return the maximum
    auto vec = std::vector<std::int32_t>{vec_size};
    std::generate(std::begin(vec), std::end(vec), std::rand);
    auto it = std::max_element(std::begin(vec), std::end(vec));
    return *it;
}

auto main() -> int
{
    auto f1 = std::async(std::launch::async, task1);
    auto f2 = std::async(std::launch::async, task2);
    
    f1.get(); // task1 has return type void
    auto res = f2.get();
    
    return 0;
}
\end{lstlisting}

\subsubsection{\texttt{std::async} -- lazy evaluation}\label{app:scorep_conc_async_lazy}

\begin{lstlisting}
#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <future>
#include <iterator>
#include <numeric>
#include <vector>

constexpr auto vec_size = std::size_t{1000000};

auto task1() -> void
{
    // fill a vector with values (vec_size, 0] and sort it
    auto vec = std::vector<std::int32_t>{vec_size};
    std::iota(std::rbegin(vec), std::rend(vec), 0);
    std::sort(std::begin(vec), std::end(vec));
}

auto task2() -> std::int32_t
{
    // fill a vector with random values and return the maximum
    auto vec = std::vector<std::int32_t>{vec_size};
    std::generate(std::begin(vec), std::end(vec), std::rand);
    auto it = std::max_element(std::begin(vec), std::end(vec));
    return *it;
}

auto main() -> int
{
    auto f1 = std::async(std::launch::deferred, task1);
    auto f2 = std::async(std::launch::deferred, task2);
    
    f1.get(); // task1 has return type void
    auto res = f2.get();
    
    return 0;
}
\end{lstlisting}

\subsubsection{\texttt{std::thread} -- spawn and join}\label{app:conc_thread_join}

\begin{lstlisting}
#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <iterator>
#include <numeric>
#include <thread>
#include <vector>

constexpr auto vec_size = std::size_t{1000000};

auto f() -> void
{
    auto vec = std::vector<std::int32_t>{vec_size};
    std::iota(std::rbegin(vec), std::rend(vec), 0);
    std::sort(std::begin(vec), std::end(vec));
}

auto main() -> int
{
    auto t = std::thread{f};
    t.join();
    
    return 0;
}
\end{lstlisting}

\subsubsection{\texttt{std::thread} -- spawn and detach}\label{app:conc_thread_detach}

\begin{lstlisting}
#include <algorithm>
#include <chrono>
#include <cstddef>
#include <cstdint>
#include <iterator>
#include <numeric>
#include <thread>
#include <vector>

constexpr auto vec_size = std::size_t{1000000};

auto f() -> void
{
    auto vec = std::vector<std::int32_t>{vec_size};
    std::iota(std::rbegin(vec), std::rend(vec), 0);
    std::sort(std::begin(vec), std::end(vec));
}

auto main() -> int
{
    auto t = std::thread{f};
    t.detach();
    
    using namespace std::chrono_literals;
    std::this_thread::sleep_for(5s);
    
    return 0;
}
\end{lstlisting}

\subsection{Synchronization}\label{app:scorep_sync}

\subsubsection{\texttt{std::mutex}}\label{app:scorep_sync_mutex}

\begin{lstlisting}
#include <iostream>
#include <mutex>

#include <pthread.h>
#include <unistd.h>

std::mutex m;

auto f1(void*) -> void*
{
    std::lock_guard<std::mutex> l(m);
    std::cout << "Mutex locked in f1" << std::endl;
    usleep(20 * 1000);
    return nullptr;
}

auto f2(void*) -> void*
{
    usleep(10 * 1000);
    std::lock_guard<std::mutex> l(m);
    std::cout << "Mutex locked in f2" << std::endl;
    usleep(20 * 1000);
    return nullptr;
}
\end{lstlisting}

\subsubsection{\texttt{std::condition\_variable}}\label{app:scorep_sync_cv}

\begin{lstlisting}
#include <algorithm>
#include <array>
#include <condition_variable>
#include <iostream>
#include <iterator>
#include <mutex>

#include <pthread.h>
#include <unistd.h>

std::condition_variable cv;
std::mutex m;

auto done = false;

auto wait(void*) -> void*
{
    std::unique_lock<std::mutex> l(m);
    std::cout << "Waiting...\n";
    cv.wait(l, []{ return done; });
    std::cout << "...finished waiting. done == true\n";
    return nullptr;
}

auto signal(void*) -> void*
{
}

auto main() -> int
{
    auto threads = std::array<pthread_t, 4>{};
    std::for_each(std::begin(threads), std::begin(threads) + 3, [](auto& t){ pthread_create(&t, nullptr, wait, 0); });
    pthread_create(&threads[3], nullptr, signal, 0);
    
    for(auto&& t : threads)
        pthread_join(t, nullptr);
        
    return 0;
}
\end{lstlisting}

\subsection{File I/O}

\subsubsection{\texttt{std::fstream} in binary mode}\label{app:scorep_binary_fstream}

\begin{lstlisting}
#include <algorithm>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

auto main() -> int
{
    auto path = std::string{"test.bin"};
    auto output = std::vector<int>{};
    auto input = std::vector<int>{};
    output.resize(1000);
    input.resize(1000);
    
    std::generate(std::begin(output), std::end(output), std::rand);
    
    {
        std::ofstream out{path.c_str(), std::ios::binary};
        out.write(reinterpret_cast<const char*>(output.data()), output.size() * sizeof(int));
    }
    {
        std::ifstream in{path.c_str(), std::ios::binary};
        in.read(reinterpret_cast<char*>(input.data()), input.size() * sizeof(int));
    }
    
    if(!std::equal(std::begin(output), std::end(output), std::begin(input)))
        std::cerr << "Error: Input does not match output." << std::endl;
        
    return 0;
}
\end{lstlisting}

\subsubsection{\texttt{std::fstream} in text mode}\label{app:scorep_text_fstream}

\begin{lstlisting}
#include <fstream>
#include <iostream>
#include <string>

auto main() -> int
{
    auto path = std::string{"test.txt"};
    
    {
        std::ofstream out{path.c_str()};
        out << "Lorem ipsum dolor sit amet, consetetur sadipscing elitir, sed diam nonumy\n"
        << "eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam\n"
		<< "voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita\n"
		<< "kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem\n"
		<< "ipsum dolor sit amet, consetetur sadipscing elitir, sed diam nonumy eirmod"
		<< std::endl;
	}
	{
		std::ifstream in{path.c_str()};
		in >> std::cout.rdbuf();
	}
	
	return 0;
}
\end{lstlisting}

\subsubsection{\texttt{C-style I/O}}\label{app:scorep_c_io}

\begin{lstlisting}
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>

auto main() -> int
{
    auto path = std::string{"test.bin"};
    auto output = std::vector<int>{};
    auto input = std::vector<int>{};
    output.resize(1000);
    input.resize(1000);
    
    std::generate(std::begin(output), std::end(output), std::rand);
    
    auto out = std::fopen(path.c_str(), "wb");
    std::fwrite(output.data(), sizeof(int), output.size(), out);
    std::fclose(out);
    
    auto in = std::fopen(path.c_str(), "rb");
    std::fread(input.data(), sizeof(int), input.size(), in);
    std::fclose(in);
    
    if(!std::equal(std::begin(output), std::end(output), std::begin(input)))
        std::cerr << "Error: Input does not match output." << std::endl;
        
    return 0;
}
\end{lstlisting}

\end{appendix}